Gateway API
     Gateway API is the next-generation networking API in Kubernetes
     It provides a standard, role-oriented, extensible way to manage north‚Äìsouth traffic (traffic coming into your cluster).

    Think of it as:
    ‚ÄúIngress 2.0 ‚Äî with more power, flexibility, and real-world usability.‚Äù

    üß© Why Gateway API was created

    The old Ingress resource had limitations:

    | Problem with Ingress                                 | Why it‚Äôs an issue                                           |
    | ---------------------------------------------------- | ----------------------------------------------------------- |
    | Only supports basic HTTP routing                     | Hard to manage advanced scenarios (headers, paths, weights) |
    | Controller-specific annotations                      | Vendor lock-in (e.g., NGINX vs Istio vs Traefik)            |
    | No clear separation of roles                         | DevOps & developers use same YAML ‚Äî messy and risky         |
    | Hard to express multi-team / multi-tenant networking | No namespace-scoped control                                 |

    Gateway API was built by the Kubernetes SIG-Network group to fix these ‚Äî
    with better design, more granular control, and extensibility.


    üß† Gateway API Key Concepts

        Gateway API introduces a set of resources, not just one:

        | Resource                                                   | Purpose                                                                                                                    |
        | ---------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
        | **GatewayClass**                                           | Defines a type of Gateway (e.g., NGINX, Istio, HAProxy implementation). Similar to `IngressClass`.                         |
        | **Gateway**                                                | The actual data plane entry point ‚Äî defines how and where traffic enters the cluster (like LoadBalancer, IP, or NodePort). |
        | **HTTPRoute / TCPRoute / GRPCRoute / TLSRoute / UDPRoute** | Define the routing rules ‚Äî how requests are matched and forwarded to Services.                                             |
        | **BackendPolicy / ReferenceGrant**                         | Advanced policies and permissions for backends (security, TLS, etc.).                                                      |

    
    ‚öôÔ∏è Gateway API Architecture Overview

           +-------------------+
Internet ‚Üí |    Gateway        |   (entry point)
           +-------------------+
                     |
                     v
              +--------------+
              |  HTTPRoute   |  (routing logic)
              +--------------+
                     |
                     v
              +--------------+
              |   Service    |  (backend workload)
              +--------------+


    üöÄ Gateway API vs Ingress (Key Differences)
    | Feature                     | **Ingress**                     | **Gateway API**                                                               |
    | --------------------------- | ------------------------------- | ----------------------------------------------------------------------------- |
    | **Resource model**          | Single `Ingress` resource       | Multiple resources (`Gateway`, `HTTPRoute`, etc.)                             |
    | **Traffic types**           | HTTP/HTTPS only                 | HTTP, HTTPS, TCP, UDP, gRPC                                                   |
    | **Extensibility**           | Controller-specific annotations | Extensible fields and CRDs, standard schema                                   |
    | **Multi-tenancy**           | Hard to manage (shared Ingress) | Native support ‚Äî teams can define their own Routes binding to shared Gateways |
    | **Cross-namespace routing** | Not supported                   | Supported via `ReferenceGrant`                                                |
    | **Role separation**         | Not possible                    | Operators define Gateways; app teams define Routes                            |
    | **Advanced routing**        | Limited                         | Weighted traffic splitting, header matching, filters, path rewrites           |
    | **Status reporting**        | Minimal                         | Rich, per-object status and conditions                                        |
    | **Standardization**         | Vendor-specific behavior        | Unified spec across vendors (NGINX, Istio, Envoy, etc.)                       |


    üîç How It Works

        GatewayClass: defines what controller handles the traffic (e.g., NGINX, Istio, Traefik).
        Gateway: is created by cluster/network admins ‚Äî defines listener ports (e.g., port 80).
        HTTPRoute: created by app developers ‚Äî defines routing (e.g., /app ‚Üí webapp-service).
        Controller (e.g., NGINX Gateway) reconciles all of this and manages load balancers automatically.

    üåü Gateway API Features

        ‚úÖ Multi-protocol support ‚Äî HTTP, HTTPS, TCP, UDP, gRPC
        ‚úÖ Native multi-tenancy ‚Äî different teams, one Gateway
        ‚úÖ Cross-namespace routing via ReferenceGrant
        ‚úÖ Role-based model (Infra vs App Dev separation)
        ‚úÖ Advanced traffic rules ‚Äî header match, weight-based routing, rewrites
        ‚úÖ Controller-agnostic (works with NGINX, Istio, HAProxy, Envoy, etc.)
        ‚úÖ Better observability and status feedback
        ‚úÖ Extensible ‚Äî vendors can add their own CRDs cleanly